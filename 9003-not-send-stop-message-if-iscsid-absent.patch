From 1412b27dc88f5f2cdda5cb1cf0d2a9313313a390 Mon Sep 17 00:00:00 2001
From: pengyeqing <pengyeqing@huawei.com>
Date: Mon, 20 Jan 2020 19:43:52 +0800
Subject: [PATCH] iscsi-initiator-utils: not send stop message if iscsid absent

Signed-off-by: pengyeqing <pengyeqing@huawei.com>
---
 etc/systemd/iscsid.service |  2 ++
 usr/iscsiadm.c             | 71 ++++++++++++++++++++++++++++++++++++++++++++++
 2 files changed, 73 insertions(+)

diff --git a/etc/systemd/iscsid.service b/etc/systemd/iscsid.service
index 2566b49..44a0363 100644
--- a/etc/systemd/iscsid.service
+++ b/etc/systemd/iscsid.service
@@ -9,6 +9,8 @@ PIDFile=/var/run/iscsid.pid
 ExecStart=/usr/sbin/iscsid
 ExecStartPost=/usr/bin/sleep 1
 ExecStop=/sbin/iscsiadm -k 0 2
+Restart=always
+RestartSec=2s
 
 [Install]
 WantedBy=multi-user.target
diff --git a/usr/iscsiadm.c b/usr/iscsiadm.c
index 4796c2f..8b5d5fe 100644
--- a/usr/iscsiadm.c
+++ b/usr/iscsiadm.c
@@ -69,6 +69,8 @@ static char program_name[] = "iscsiadm";
 static char config_file[TARGET_NAME_MAXLEN];
 extern struct iscsi_ipc *ipc;
 
+#define ISCSIPID_LEN 256
+
 enum iscsiadm_mode {
 	MODE_DISCOVERY,
 	MODE_DISCOVERYDB,
@@ -267,11 +269,52 @@ str_to_portal_type(char *str)
 	return ptype;
 }
 
+/**
+ *  get_content() - Utility function to read hex values from sysfs
+ *  @param pidfile - path to use
+ *  @parm buf - this is the value returned from the entry
+ *  @return 0 on success <0 on failure
+ *  @note: buf[] return without '\0'
+ */
+static int get_file_content(const char *pidfile, char buf[], int buflen)
+{
+	int rc = 0;
+	FILE *fp = NULL;
+	size_t chars_read = 0;
+
+	fp = fopen(pidfile, "r");
+	if (fp == NULL) {
+		log_error("Could not open path: %s [%s]",
+			pidfile, strerror(errno));
+		rc = -EIO;
+		goto error_fopen;
+	}
+
+	chars_read = fread(buf, 1, buflen, fp);
+	if ((chars_read <= 0) && ferror(fp)) {
+		log_error("Could not read from: %s [%s]",
+			pidfile, strerror(ferror(fp)));
+		rc = -EIO;
+		goto error;
+	}
+
+error:
+	fclose(fp);
+
+error_fopen:
+	return rc;
+}
+
 static void kill_iscsid(int priority, int tmo)
 {
 	iscsiadm_req_t req;
 	iscsiadm_rsp_t rsp;
 	int rc;
+	char *pTmp = NULL;
+	char iscsidpid[ISCSIPID_LEN] = {0};
+	char procpid[ISCSIPID_LEN] = {0};
+	char cmdline[ISCSIPID_LEN] = {0};
+	char iscsidcmdline[ISCSIPID_LEN] = {0};
 
 	/*
 	 * We only support SIGTERM like stoppage of iscsid for now.
@@ -287,6 +330,34 @@ static void kill_iscsid(int priority, int tmo)
 		return;
 	}
 
+	/* if pid of iscsid is present, go on; or return directly */
+	rc = get_file_content(PID_FILE, iscsidpid, ISCSIPID_LEN);
+	if (rc != 0) {
+		return;
+	}
+
+	snprintf(procpid, ISCSIPID_LEN, "/proc/%ld/cmdline", atol(iscsidpid));
+
+	rc = get_file_content(procpid, cmdline, ISCSIPID_LEN);
+	if (rc != 0) {
+		return;
+	}
+
+	snprintf(iscsidcmdline, ISCSIPID_LEN, "%s", cmdline);
+
+	pTmp = strstr(iscsidcmdline, "iscsid");
+	if (NULL == pTmp) {
+		log_error("iscsid pid mismatch proc cmdline, pid:%ld, cmdline:%s.\n", atol(iscsidpid), iscsidcmdline);
+		return;
+	} else {
+		rc = kill(atol(iscsidpid), 0);
+		if (ESRCH == rc) {
+			log_error("iscsid %d maybe in zombie.\n", atol(iscsidpid));
+			return;
+		}
+	}
+    /* end */
+
 	memset(&req, 0, sizeof(req));
 	req.command = MGMT_IPC_IMMEDIATE_STOP;
 	rc = iscsid_exec_req(&req, &rsp, 0, tmo);
-- 
1.8.3.1

